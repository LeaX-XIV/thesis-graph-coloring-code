#version 460

struct Node {
    int color;
	int neighbours;
	int next_neighbours;
};

layout(set = 0, binding = 0) buffer InAoBuffer {
    int Ao[];
};

layout(set = 0, binding = 1) buffer InAcBuffer {
    int Ac[];
};

layout(set = 0, binding = 2) buffer InRandomBuffer {
    int randoms[];
};

layout(set = 0, binding = 3) buffer InOutColors {
    int colors[];
};

layout(set = 0, binding = 4) buffer OutFinished {
    int finished[];
};

layout(push_constant) uniform PushConstants {
    int current_color;
} push;

layout(constant_id = 0) const uint xSize = 0;
layout(constant_id = 1) const uint first = 0;
layout(constant_id = 2) const uint last = 0;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

bool color_jpl_ignore_neighbor(in const int c, in uint i, in const uint j, in const int jc)
{
    return ((jc != -1) && (jc != c) && (jc != c + 1)) || (i == j);
}

bool color_jpl_assign_color(in const int color, in const uint index, in const ivec2 local_max_min_color)
{
    if(bool(local_max_min_color.x + local_max_min_color.y))
    {
        colors[index] = ((color + 1) * local_max_min_color.y + color * local_max_min_color.x) / (local_max_min_color.x + local_max_min_color.y);
        return true;
    }
    return false;
}

void main()
{
    bool local_finished = true;
    for(uint index = gl_GlobalInvocationID.y * xSize + gl_GlobalInvocationID.x; index < last - first; index += xSize) {
        if (colors[index] != -1) break;
        ivec2 local_max_min_color = ivec2(1, 1);
        const ivec4 base_current_next_color = ivec4(Ao[0], Ao[index], Ao[index + 1], push.current_color * 2);
        for(int k = base_current_next_color.y; k < base_current_next_color.z; k++) {
            const uint j = Ac[k - base_current_next_color.x] - first;
            const bool ignore = color_jpl_ignore_neighbor(base_current_next_color.w, index, j, colors[j]);
            if(j < 0 || (j >= last - first) || ignore) continue;
            const ivec2 i_jr = ivec2(randoms[(index + (base_current_next_color.w << 1)) % (last - first)], randoms[(j + (base_current_next_color.w << 1)) % (last - first)]);
            local_max_min_color = local_max_min_color * ivec2(int(i_jr.x > i_jr.y), int(i_jr.x < i_jr.y));
        }
        local_finished = local_finished && color_jpl_assign_color(base_current_next_color.w, index, local_max_min_color);
    }
    if(!local_finished) {
        finished[0] = 0;
    }
}
